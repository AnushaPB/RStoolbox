<!DOCTYPE html><html><head><title>R: Unsupervised Classification</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/languages/r.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head><body><div class="container">

<table style="width: 100%;"><tr><td>unsuperClass {RStoolbox}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Unsupervised Classification</h2>

<h3>Description</h3>

<p>Unsupervised clustering of SpatRaster data using kmeans clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unsuperClass(
  img,
  nSamples = 10000,
  nClasses = 5,
  nStarts = 25,
  nIter = 100,
  norm = FALSE,
  clusterMap = TRUE,
  algorithm = "Hartigan-Wong",
  output = "classes",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;"><td><code>img</code></td>
<td>
<p>SpatRaster.</p>
</td></tr>
<tr style="vertical-align: top;"><td><code>nSamples</code></td>
<td>
<p>Integer. Number of random samples to draw to fit cluster map. Only relevant if clusterMap = TRUE.</p>
</td></tr>
<tr style="vertical-align: top;"><td><code>nClasses</code></td>
<td>
<p>Integer. Number of classes.</p>
</td></tr>
<tr style="vertical-align: top;"><td><code>nStarts</code></td>
<td>
<p>Integer. Number of random starts for kmeans algorithm.</p>
</td></tr>
<tr style="vertical-align: top;"><td><code>nIter</code></td>
<td>
<p>Integer. Maximal number of iterations allowed.</p>
</td></tr>
<tr style="vertical-align: top;"><td><code>norm</code></td>
<td>
<p>Logical. If <code>TRUE</code> will normalize img first using <a href="../../RStoolbox/help/normImage.html">normImage</a>. Normalizing is beneficial if your predictors have different scales.</p>
</td></tr>
<tr style="vertical-align: top;"><td><code>clusterMap</code></td>
<td>
<p>Logical. Fit kmeans model to a random subset of the img (see Details).</p>
</td></tr>
<tr style="vertical-align: top;"><td><code>algorithm</code></td>
<td>
<p>Character. <a href="../../stats/help/kmeans.html">kmeans</a> algorithm. One of c(&quot;Hartigan-Wong&quot;, &quot;Lloyd&quot;, &quot;MacQueen&quot;)</p>
</td></tr>
<tr style="vertical-align: top;"><td><code>output</code></td>
<td>
<p>Character. Either 'classes' (kmeans class; default) or 'distances' (euclidean distance to each cluster center).</p>
</td></tr>
<tr style="vertical-align: top;"><td><code>...</code></td>
<td>
<p>further arguments to be passed to <a href="../../terra/help/writeRaster.html">writeRaster</a>, e.g. filename</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clustering is done using <code><a href="../../stats/help/kmeans.html">kmeans</a></code>. This can be done for all pixels of the image (<code>clusterMap=FALSE</code>), however this can be slow and is
not memory safe. Therefore if you have large raster data (&gt; memory), as is typically the case with remote sensing imagery it is advisable to choose clusterMap=TRUE (the default).
This means that a kmeans cluster model is calculated based on a random subset of pixels (<code>nSamples</code>). Then the distance of *all* pixels to the cluster centers 
is calculated in a stepwise fashion using <code><a href="../../terra/help/predict.html">predict</a></code>. Class assignment is based on minimum euclidean distance to the cluster centers.
</p>
<p>The solution of the kmeans algorithm often depends on the initial configuration of class centers which is chosen randomly. 
Therefore, kmeans is usually run with multiple random starting configurations in order to find a convergent solution from different starting configurations.
The <code>nStarts</code> argument allows to specify how many random starts are conducted.
</p>


<h3>Value</h3>

<p>Returns an RStoolbox::unsuperClass object, which is a list containing the kmeans model ($model) and the raster map ($map).
For output = &quot;classes&quot;, $map contains a SpatRaster with discrete classes (kmeans clusters); for output = &quot;distances&quot; $map contains
a SpatRaster, with 'nClasses' layers, where each layer maps the euclidean distance to the corresponding class centroid.
</p>


<h3>Examples</h3>

<pre><code class="language-r">## Not run: 
##D library(terra)
##D input &lt;- rlogo
##D 
##D ## Plot 
##D olpar &lt;- par(no.readonly = TRUE) # back-up par
##D par(mfrow=c(1,2))
##D plotRGB(input)
##D 
##D ## Run classification
##D set.seed(25)
##D unC &lt;- unsuperClass(input, nSamples = 100, nClasses = 5, nStarts = 5)
##D unC
##D 
##D ## Plots
##D colors &lt;- rainbow(5)
##D plot(unC$map, col = colors, legend = FALSE, axes = FALSE, box = FALSE)
##D legend(1,1, legend = paste0(&quot;C&quot;,1:5), fill = colors, title = &quot;Classes&quot;, horiz = TRUE,  bty = &quot;n&quot;)
##D 
##D ## Return the distance of each pixel to each class centroid
##D unC &lt;- unsuperClass(input, nSamples = 100, nClasses = 3, output = &quot;distances&quot;)
##D unC
##D 
##D ggR(unC$map, 1:3, geom_raster = TRUE)
##D 
##D par(olpar) # reset par
## End(Not run)
</code></pre>


<hr /><div style="text-align: center;">[Package <em>RStoolbox</em> version 0.4.0 <a href="00Index.html">Index</a>]</div>
</div>
</body></html>
